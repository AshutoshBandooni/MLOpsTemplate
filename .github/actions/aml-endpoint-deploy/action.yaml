name: Deploying endpoint
description: 'Deploys a model endpoint in Azure Machine Learning Services all along with all the deployments it contains. Logs are collected and uploaded.'

inputs:
  endpointFile:
    description: 'Path to the endpoint YAML file. Wildcard paths are supported which means that all matched endpoints will be deployed.'
    required: true
  deploymentFile:
    description: 'Path to the deployment YAML files for the given endpoints. This path is relative to the path where the endpoints are located.'
    required: true
  modelVersion:
    description: 'Model version you want to deploy. If this specified, it will overwrite the version indicated in the deployment file. Otherwise, the one indicated there will be used.'
    required: false
    default: ''
  workspaceName:
    description: 'Name of the workspace to work against.'
    required: true
  resourceGroup:
    description: 'Name of the resource group where the workspace is placed.'
    required: true
  noWait:
    description: 'Indicates if the action should not wait for the deployment to finish.'
    required: false
    default: 'false'
  secretsToKeyVault:
    description: 'Indicates if the `scoring uri` and the `scoring key` should be uploaded to Azure Key Vault. Secrets naming convention is `<ENDPOINT_NAME>_scoringUri` and `<ENDPOINT_NAME>_scoringKey`.'
    required: false
    default: 'false'
  keyVaultName:
    description: 'The name of the key vault to use. Required if `secretsToKeyVault` is `true`.'
    required: false
    default: ''
  updateIfExists:
    description: 'If endpoint exists, by pass creation, if deployment exist, update it'
    required: false
    default: 'true'
outputs:
  deployedVersion:
    description: 'Deployed version of the model'
    value: ${{ steps.deployment.outputs.deployedVersion }}

runs:
  using: "composite"
  steps:
    - name: Deploying endpoint
      id: deployment
      shell: bash
      run: |
        set -e
        az configure --defaults workspace=${{ inputs.workspaceName }} group=${{ inputs.resourceGroup }}

        ENDPOINT_FILES=$(find ${{ inputs.endpointFile }})
        for ENDPOINT_FILE in $ENDPOINT_FILES
        do
          ENDPOINT_FOLDER=$(dirname $ENDPOINT_FILE)
          ENDPOINT_NAME=$(yq -r ".name" $ENDPOINT_FILE)
          echo "ENDPOINT_FOLDER: $ENDPOINT_FOLDER"
          echo "ENDPOINT_NAME: $ENDPOINT_NAME"

          # We are removing traffic key since this has the chicken and the egg issue. If you place .traffic you have
          # to deploy the deployment first. But you can't deploy deployments without an endpoint.
          echo "::debug::Rewriting endpoint file without traffic"
          yq -y "del(.traffic)" $ENDPOINT_FILE > $ENDPOINT_NAME.yml
          if ${{ inputs.updateIfExists }}; then
            { 
                echo "Creating endpoint with name: $ENDPOINT_NAME" &&
                az ml online-endpoint create -f $ENDPOINT_NAME.yml
            } || { 
                echo "Endpoint $ENDPOINT_NAME already exists, bypassing endpoint creation"
            }
          fi

          echo "::debug::Retrieving URL and credentials"
          SCORING_URI=$(az ml online-endpoint show -n $ENDPOINT_NAME | jq -r ".scoring_uri")
          SCORING_KEY=$(az ml online-endpoint get-credentials -n $ENDPOINT_NAME -o tsv --query primaryKey)
            
          echo "::debug::Looking for deployments in folder $ENDPOINT_FOLDER/${{ inputs.deploymentFile }}"
          DEPLOYMENT_FILES=$(find $ENDPOINT_FOLDER/${{ inputs.deploymentFile }})
          
          echo "Reading deployments slot_types to select deployment name for staging..."
          STAGING_DEPLOYMENT_NAME=$(az ml online-deployment list -e mlops-workshop-endpoint --query "[?tags.slot_type=='staging'].{name:name}" -o json | yq .[0].name)
          PRODUCTION_DEPLOYMENT_NAME=$(az ml online-deployment list -e mlops-workshop-endpoint --query "[?tags.slot_type=='production'].{name:name}" -o json | yq .[0].name)
          if $STAGING_DEPLOYMENT_NAME == null; then
            if $PRODUCTION_DEPLOYMENT_NAME == null; then
              STAGING_DEPLOYMENT_NAME = 'blue'
            else
              if $PRODUCTION_DEPLOYMENT_NAME == 'blue'; then
                STAGING_DEPLOYMENT_NAME = 'green'
              else
                STAGING_DEPLOYMENT_NAME = 'blue'
              fi
            fi
          fi
          DEPLOYMENT_NAME=$STAGING_DEPLOYMENT_NAME
          echo "DEPLOYMENT_NAME: $DEPLOYMENT_NAME"

          for DEPLOYMENT_FILE in $DEPLOYMENT_FILES
          do
            echo "::debug::Working on deployment file $DEPLOYMENT_FILE"
            yq -i ".name= $DEPLOYMENT_NAME" $DEPLOYMENT_FILE
            DEPLOYMENT_MODEL=$(yq -r ".model" $DEPLOYMENT_FILE | cut -d: -f2)
            DEPLOYMENT_MODEL_VERSION=$(yq -r ".model" $DEPLOYMENT_FILE | cut -d: -f3)

            # User can overwrite the version in the YAML 
            if [ -z "${{ inputs.modelVersion }}" ]; then
              TARGET_MODEL_VERSION=$DEPLOYMENT_MODEL_VERSION
            else
              echo "::debug::Model being targeted is being overwriten with version ${{ inputs.modelVersion }}"
              TARGET_MODEL_VERSION=${{ inputs.modelVersion }}
            fi
            
            echo "::debug::Working on deployment with name: $ENDPOINT_NAME/$DEPLOYMENT_NAME"

            if [[ "$TARGET_MODEL_VERSION" == "current" ]]; then
              echo "::debug::Identifying current version of the model at deployment $ENDPOINT_NAME/$DEPLOYMENT_NAME"
              MODEL_CURRENT_URL=$(az ml online-deployment show --name $DEPLOYMENT_NAME --endpoint-name $ENDPOINT_NAME | jq -r ".model")
              MODEL_CURRENT=$(basename $MODEL_CURRENT_URL)

              echo "::debug::Updating yaml files with current model version: $MODEL_CURRENT"
              sed -i 's/:'$DEPLOYMENT_MODEL_VERSION'/:'$MODEL_CURRENT'/' $DEPLOYMENT_FILE
            fi

            if [[ "$TARGET_MODEL_VERSION" == "latest" ]]; then
              echo "::debug::Identifying latest version of the model $DEPLOYMENT_MODEL"
              MODEL_LATEST=$(az ml model list --name $DEPLOYMENT_MODEL | jq -r '.[0].version')
              
              echo "::debug::Updating yaml files with latest model version: $MODEL_LATEST"
              sed -i 's/:'$DEPLOYMENT_MODEL_VERSION'/:'$MODEL_LATEST'/' $DEPLOYMENT_FILE 
            fi

            if [[ "$TARGET_MODEL_VERSION" == *=* ]]; then
              echo "::debug::Identifying version of the model $DEPLOYMENT_MODEL with tags $TARGET_MODEL_VERSION"
              TARGET_MODEL_TAG=$($TARGET_MODEL_VERSION | cut -d= -f1)
              TARGET_MODEL_TVALUE=$($TARGET_MODEL_VERSION | cut -d= -f2)

              MODEL_TAGGED=$(az ml model list -n $DEPLOYMENT_MODEL | jq -r --arg TARGET_MODEL_TAG $TARGET_MODEL_TAG --arg TARGET_MODEL_TVALUE $TARGET_MODEL_TVALUE '.[] | select(.tags.$TARGET_MODEL_TAG == $TARGET_MODEL_TVALUE) | .version')
              echo "::debug::Updating yaml files with model version: $MODEL_TAGGED"
              sed -i 's/:'$DEPLOYMENT_MODEL_VERSION'/:'$MODEL_TAGGED'/' $DEPLOYMENT_FILE 
            fi

            echo "::debug::Creating deployment with name: $ENDPOINT_NAME/$DEPLOYMENT_NAME"
            if ${{ inputs.noWait }}; then
              az ml online-deployment create -f $DEPLOYMENT_FILE --only-show-errors --no-wait --set tags.slot_type=staging --set tags.git_commit=${GITHUB_SHA}
            else
              az ml online-deployment create -f $DEPLOYMENT_FILE --only-show-errors --set tags.slot_type=staging --set tags.git_commit=${GITHUB_SHA}

              echo "::debug::Configuring traffic for $ENDPOINT_NAME/$DEPLOYMENT_NAME"
              TRAFFIC=$(yq --arg DEPLOYMENT_NAME $DEPLOYMENT_NAME '.traffic | select(has($DEPLOYMENT_NAME)) | .[]' $ENDPOINT_FILE)
              if [[ -n $TRAFFIC ]]; then
                echo "::debug::Configuring traffic for $ENDPOINT_NAME/$DEPLOYMENT_NAME with value $TRAFFIC"
                az ml online-endpoint update -n $ENDPOINT_NAME --traffic "$DEPLOYMENT_NAME=$TRAFFIC"
              else
                echo "::warning file=$ENDPOINT_FILE::Traffic is not indicated for $ENDPOINT_NAME/$DEPLOYMENT_NAME. You will have to configure traffic later."
              fi
  
              echo "::debug::Adquiring logs for deployment with name: $ENDPOINT_NAME/$DEPLOYMENT_NAME"
              mkdir -p logs
              az ml online-deployment get-logs --name $DEPLOYMENT_NAME --endpoint-name $ENDPOINT_NAME >> logs/$ENDPOINT_NAME_$DEPLOYMENT_NAME.log
            fi

            echo "::debug::Deployment completed"
          done
        
          if ${{ inputs.secretsToKeyVault }}; then
            echo "Uploading secrets to key vault ${{ inputs.keyVaultName }}"
            echo "SCORING_URI: $SCORING_URI"
            echo "SCORING_KEY: $SCORING_KEY"
            az keyvault secret set --vault-name ${{ inputs.keyVaultName }} --name ${ENDPOINT_NAME//-/}ScoringUri --value $SCORING_URI
            az keyvault secret set --vault-name ${{ inputs.keyVaultName }} --name ${ENDPOINT_NAME//-/}ScoringKey --value $SCORING_KEY
          fi
          echo "SCORING_URI=$SCORING_URI" >> $GITHUB_ENV
          echo "SCORING_KEY=$SCORING_KEY" >> $GITHUB_ENV
          echo "::debug::Getting deployed version for model at file $DEPLOYMENT_FILE"
          DEPLOYED_VERSION=$(yq -r ".model" $DEPLOYMENT_FILE | cut -d: -f3)
          echo "::set-output name=deployedVersion::$DEPLOYED_VERSION"
          echo "Model deployed version is: $DEPLOYED_VERSION"

          echo "::debug::Endpoint deployment completed"
        done

    - name: Uploading deployment logs
      uses: actions/upload-artifact@v2
      if: ${{ (failure() || success()) && inputs.noWait == 'false' }}
      with:
        name: deployment-logs
        path: logs/*
